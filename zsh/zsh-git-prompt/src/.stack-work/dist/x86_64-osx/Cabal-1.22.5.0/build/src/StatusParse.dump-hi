
==================== FINAL INTERFACE ====================
2019-02-04 11:14:19.359668 UTC

interface gitpr_GyKbGQsRujX2Ik9bjYPmgX:StatusParse 7103
  interface hash: 62378ae5a14251be6cd519ff57df5648
  ABI hash: b9489809b2cc70ff55397d3768566180
  export-list hash: d57064a6aca95ce6bc537df92c062998
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 4c0a7b65a6dddbc4161c2e2bfabe3dc3
  sig of: Nothing
  used TH splices: False
  where
exports:
  StatusParse.countByType
  StatusParse.countStatus
  StatusParse.extractMiniStatus
  StatusParse.isChanged
  StatusParse.isConflict
  StatusParse.isStaged
  StatusParse.isUntracked
  StatusParse.processStatus
  StatusParse.MiniStatus{StatusParse.MkMiniStatus}
  StatusParse.Status{StatusParse.MakeStatus StatusParse.changed StatusParse.conflict StatusParse.staged StatusParse.untracked}
module dependencies:
package dependencies: base-4.8.2.0* ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Monoid
                         base-4.8.2.0:Data.Type.Equality base-4.8.2.0:GHC.Generics
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.Traversable 7576318f4ef8587ad947f87012b65abf
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
7a89a29ab39a6bc916937d665ad05825
  $fEqStatus ::
    GHC.Classes.Eq a => GHC.Classes.Eq (StatusParse.Status a)
  DFunId[0]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a $dEq :: GHC.Classes.Eq a.
                  @ (StatusParse.Status a)
                  (StatusParse.$fEqStatus_$c== @ a $dEq)
                  (StatusParse.$fEqStatus_$c/= @ a $dEq) -}
7a89a29ab39a6bc916937d665ad05825
  $fEqStatus_$c/= ::
    GHC.Classes.Eq a =>
    StatusParse.Status a -> StatusParse.Status a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,U,U,U)><S,1*U(U,U,U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   $dEq :: GHC.Classes.Eq a
                   a1 :: StatusParse.Status a
                   b :: StatusParse.Status a ->
                 case StatusParse.$fEqStatus_$c== @ a $dEq a1 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
7a89a29ab39a6bc916937d665ad05825
  $fEqStatus_$c== ::
    GHC.Classes.Eq a =>
    StatusParse.Status a -> StatusParse.Status a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,U,U,U)><S,1*U(U,U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   w :: GHC.Classes.Eq a
                   w1 :: StatusParse.Status a
                   w2 :: StatusParse.Status a ->
                 case w1 of ww { StatusParse.MakeStatus ww1 ww2 ww3 ww4 ->
                 case w2 of ww5 { StatusParse.MakeStatus ww6 ww7 ww8 ww9 ->
                 StatusParse.$w$c== @ a w ww1 ww2 ww3 ww4 ww6 ww7 ww8 ww9 } }) -}
7a89a29ab39a6bc916937d665ad05825
  $fShowStatus ::
    GHC.Show.Show a => GHC.Show.Show (StatusParse.Status a)
  DFunId[0]
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a $dShow :: GHC.Show.Show a.
                  @ (StatusParse.Status a)
                  (StatusParse.$fShowStatus_$cshowsPrec @ a $dShow)
                  (StatusParse.$fShowStatus_$cshow @ a $dShow)
                  (StatusParse.$fShowStatus_$cshowList @ a $dShow) -}
ff45acdb1bd22a664ad8743f4117163c
  $fShowStatus1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
ddbd0dfa7d55b4d37d1ce83d495d9186
  $fShowStatus2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
40f1a2c164bceb0a29a1f730dead3121
  $fShowStatus3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "untracked = "#) -}
e2896cd7fe9b01bd9d1f1ae44582695b
  $fShowStatus4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "changed = "#) -}
04a69f05489879ad006a0542c42f1c5a
  $fShowStatus5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "conflict = "#) -}
9cc1299aad963e10ccd377025c594f6e
  $fShowStatus6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ", "#) -}
1461084960136165bf84eaae2caf03d6
  $fShowStatus7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "staged = "#) -}
c3368af63441ae0ae07523d9c5539c15
  $fShowStatus8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "MakeStatus {"#) -}
7a89a29ab39a6bc916937d665ad05825
  $fShowStatus_$cshow ::
    GHC.Show.Show a => StatusParse.Status a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><S,1*U(U,U,U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a $dShow :: GHC.Show.Show a x :: StatusParse.Status a ->
                 StatusParse.$fShowStatus_$cshowsPrec
                   @ a
                   $dShow
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
7a89a29ab39a6bc916937d665ad05825
  $fShowStatus_$cshowList ::
    GHC.Show.Show a => [StatusParse.Status a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   $dShow :: GHC.Show.Show a
                   eta :: [StatusParse.Status a]
                   eta1 :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ (StatusParse.Status a)
                   (StatusParse.$fShowStatus_$cshowsPrec
                      @ a
                      $dShow
                      StatusParse.$fShowStatus1)
                   eta
                   eta1) -}
7a89a29ab39a6bc916937d665ad05825
  $fShowStatus_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> StatusParse.Status a -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,A)><S,1*U(U)><S,1*U(U,U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   w :: GHC.Show.Show a
                   w1 :: GHC.Types.Int
                   w2 :: StatusParse.Status a ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { StatusParse.MakeStatus ww3 ww4 ww5 ww6 ->
                 StatusParse.$w$cshowsPrec @ a w ww1 ww3 ww4 ww5 ww6 } }) -}
bc0597bf9ba54ee1062325cc7f86ea53
  $w$c== ::
    GHC.Classes.Eq a =>
    a -> a -> a -> a -> a -> a -> a -> a -> GHC.Types.Bool
  {- Arity: 9, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   w :: GHC.Classes.Eq a
                   ww :: a
                   ww1 :: a
                   ww2 :: a
                   ww3 :: a
                   ww4 :: a
                   ww5 :: a
                   ww6 :: a
                   ww7 :: a ->
                 case GHC.Classes.== @ a w ww ww4 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case GHC.Classes.== @ a w ww1 ww5 of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> case GHC.Classes.== @ a w ww2 ww6 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> GHC.Classes.== @ a w ww3 ww7 } } }) -}
4240aa1a221c47fb48af099703d29a19
  $w$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Prim.Int# -> a -> a -> a -> a -> GHC.Show.ShowS
  {- Arity: 6,
     Strictness: <L,U(C(C1(U)),A,A)><L,U><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   w :: GHC.Show.Show a
                   ww :: GHC.Prim.Int#
                   ww1 :: a
                   ww2 :: a
                   ww3 :: a
                   ww4 :: a ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ a w StatusParse.$fShowStatus1 ww1
                 } in
                 let {
                   f1 :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ a w StatusParse.$fShowStatus1 ww2
                 } in
                 let {
                   f2 :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ a w StatusParse.$fShowStatus1 ww3
                 } in
                 let {
                   f3 :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ a w StatusParse.$fShowStatus1 ww4
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       StatusParse.$fShowStatus8
                       (GHC.Base.++
                          @ GHC.Types.Char
                          StatusParse.$fShowStatus7
                          (f (GHC.Base.++
                                @ GHC.Types.Char
                                StatusParse.$fShowStatus6
                                (GHC.Base.++
                                   @ GHC.Types.Char
                                   StatusParse.$fShowStatus5
                                   (f1
                                      (GHC.Base.++
                                         @ GHC.Types.Char
                                         StatusParse.$fShowStatus6
                                         (GHC.Base.++
                                            @ GHC.Types.Char
                                            StatusParse.$fShowStatus4
                                            (f2
                                               (GHC.Base.++
                                                  @ GHC.Types.Char
                                                  StatusParse.$fShowStatus6
                                                  (GHC.Base.++
                                                     @ GHC.Types.Char
                                                     StatusParse.$fShowStatus3
                                                     (f3
                                                        (GHC.Base.++
                                                           @ GHC.Types.Char
                                                           StatusParse.$fShowStatus2
                                                           x))))))))))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ x :: GHC.Base.String ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) }) -}
04f81d8a017b57d21ea9152c6b6592e6
  $wcountByType ::
    (StatusParse.MiniStatus -> GHC.Types.Bool)
    -> [StatusParse.MiniStatus] -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Inline: [0],
     Unfolding: (\ w :: StatusParse.MiniStatus -> GHC.Types.Bool
                   w1 :: [StatusParse.MiniStatus] ->
                 letrec {
                   $wgo4 :: [StatusParse.MiniStatus] -> GHC.Prim.Int# -> GHC.Prim.Int#
                     {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
                   = \ w2 :: [StatusParse.MiniStatus] ww :: GHC.Prim.Int# ->
                     case w2 of wild {
                       [] -> ww
                       : y ys
                       -> case w y of wild1 {
                            GHC.Types.False -> $wgo4 ys ww
                            GHC.Types.True -> $wgo4 ys (GHC.Prim.+# ww 1) } }
                 } in
                 $wgo4 w1 0) -}
bafefbc6c672925bd75ef4515e01f0a2
  $wcountStatus ::
    [StatusParse.MiniStatus]
    -> (# GHC.Types.Int, GHC.Types.Int, GHC.Types.Int, GHC.Types.Int #)
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ w :: [StatusParse.MiniStatus] ->
                 (# case StatusParse.$wgo3 w 0 of ww { DEFAULT -> GHC.Types.I# ww },
                    case StatusParse.$wgo2 w 0 of ww { DEFAULT -> GHC.Types.I# ww },
                    case StatusParse.$wgo1 w 0 of ww { DEFAULT -> GHC.Types.I# ww },
                    case StatusParse.$wgo w 0 of ww { DEFAULT ->
                    GHC.Types.I# ww } #)) -}
a85d364f8e73904a9615a82adaae798e
  $wgo :: [StatusParse.MiniStatus] -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0] -}
a63cd4b3bf0c1fda87100460d8b3ddfb
  $wgo1 :: [StatusParse.MiniStatus] -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0] -}
7891436dc755ff03791dc6b322faa65d
  $wgo2 :: [StatusParse.MiniStatus] -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0] -}
10c5fcd7254ca8c7332dc151914c099b
  $wgo3 :: [StatusParse.MiniStatus] -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
e3d93120656762d99b986bd912010dae
  $wisConflict :: GHC.Prim.Char# -> GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(1*U)>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Char# ww1 :: GHC.Types.Char ->
                 case ww of wild {
                   DEFAULT
                   -> case ww1 of wild1 { GHC.Types.C# c1 ->
                      case c1 of wild2 {
                        DEFAULT
                        -> case wild of wild3 {
                             DEFAULT -> GHC.Types.False
                             'A'
                             -> case wild2 of wild4 {
                                  DEFAULT -> GHC.Types.False 'A' -> GHC.Types.True }
                             'D'
                             -> case wild2 of wild4 {
                                  DEFAULT -> GHC.Types.False 'D' -> GHC.Types.True } }
                        'U' -> GHC.Types.True } }
                   'U' -> GHC.Types.True }) -}
4ad244c5eec68fa79d59eeaae4c9ab00
  $wisStaged :: GHC.Types.Char -> GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U(U)><L,1*U(1*U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Types.Char ww1 :: GHC.Types.Char ->
                 case GHC.List.elem
                        @ GHC.Types.Char
                        GHC.Classes.$fEqChar
                        ww
                        StatusParse.isStaged1 of wild {
                   GHC.Types.False
                   -> case ww of wild1 { GHC.Types.C# c1 ->
                      case c1 of wild2 {
                        DEFAULT -> GHC.Types.False
                        'A'
                        -> case ww1 of wild3 { GHC.Types.C# c2 ->
                           case c2 of wild4 {
                             DEFAULT -> GHC.Types.True 'A' -> GHC.Types.False } }
                        'D'
                        -> case ww1 of wild3 { GHC.Types.C# c2 ->
                           case c2 of wild4 {
                             DEFAULT -> GHC.Types.True 'D' -> GHC.Types.False } } } }
                   GHC.Types.True -> GHC.Types.True }) -}
fb4628c9c76d47f7ca9c4029b5b7bb6b
  data MiniStatus = MkMiniStatus GHC.Types.Char GHC.Types.Char
7a89a29ab39a6bc916937d665ad05825
  data Status a
    = MakeStatus {staged :: a,
                  conflict :: a,
                  changed :: a,
                  untracked :: a}
    Promotable
ed0b1ca7258a805ef70e7a49b8317bc3
  changed :: StatusParse.Status a -> a
  RecSel StatusParse.Status
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLSL),1*U(A,A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ds :: StatusParse.Status a ->
                 case ds of wild { StatusParse.MakeStatus ds1 ds2 ds3 ds4 ->
                 ds3 }) -}
3a30304ea1f42079fdc1cd1e250b15b2
  conflict :: StatusParse.Status a -> a
  RecSel StatusParse.Status
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSLL),1*U(A,1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ds :: StatusParse.Status a ->
                 case ds of wild { StatusParse.MakeStatus ds1 ds2 ds3 ds4 ->
                 ds2 }) -}
715fc614c5b5deb61a54852d6119772b
  countByType ::
    (StatusParse.MiniStatus -> GHC.Types.Bool)
    -> [StatusParse.MiniStatus] -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: StatusParse.MiniStatus -> GHC.Types.Bool
                   w1 :: [StatusParse.MiniStatus] ->
                 case StatusParse.$wcountByType w w1 of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
3718ad753b40168143e71d757721ce11
  countStatus ::
    [StatusParse.MiniStatus] -> StatusParse.Status GHC.Types.Int
  {- Arity: 1, Strictness: <L,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [StatusParse.MiniStatus] ->
                 case StatusParse.$wcountStatus w of ww { (#,,,#) ww1 ww2 ww3 ww4 ->
                 StatusParse.MakeStatus @ GHC.Types.Int ww1 ww2 ww3 ww4 }) -}
48409ca0c29376781271b35b64fbc4bf
  extractMiniStatus ::
    GHC.Base.String -> GHC.Base.Maybe StatusParse.MiniStatus
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: [GHC.Types.Char] ->
                 case ds of wild {
                   [] -> GHC.Base.Nothing @ StatusParse.MiniStatus
                   : ds1 ds2
                   -> case ds2 of wild1 {
                        [] -> GHC.Base.Nothing @ StatusParse.MiniStatus
                        : work ds3
                        -> GHC.Base.Just
                             @ StatusParse.MiniStatus
                             (StatusParse.MkMiniStatus ds1 work) } }) -}
786d0e1248d5e331992ae6d917b12958
  isChanged :: StatusParse.MiniStatus -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LS(S)),1*U(1*U(1*U),1*U(1*U))>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: StatusParse.MiniStatus ->
                 case ds of wild { StatusParse.MkMiniStatus index work ->
                 case work of wild1 { GHC.Types.C# c1 ->
                 case c1 of wild2 {
                   DEFAULT -> GHC.Types.False
                   'D'
                   -> case index of wild3 { GHC.Types.C# c2 ->
                      case c2 of wild4 {
                        DEFAULT -> GHC.Types.True 'D' -> GHC.Types.False } }
                   'M' -> GHC.Types.True } } }) -}
a1dbe80e31c49a7e908e69cdf0983ea9
  isConflict :: StatusParse.MiniStatus -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(1*U),1*U(1*U))>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: StatusParse.MiniStatus ->
                 case w of ww { StatusParse.MkMiniStatus ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.C# ww4 ->
                 StatusParse.$wisConflict ww4 ww2 } }) -}
84d7bd8c616bfc58888537eff7c11faf
  isStaged :: StatusParse.MiniStatus -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U(U(U),1*U(1*U))>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: StatusParse.MiniStatus ->
                 case w of ww { StatusParse.MkMiniStatus ww1 ww2 ->
                 StatusParse.$wisStaged ww1 ww2 }) -}
9f7e7fdd5316274930a4a36e75332693
  isStaged1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "MRC"#) -}
2463d62dcee44ea22ea78aef7add2d13
  isUntracked :: StatusParse.MiniStatus -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S(S)L),1*U(1*U(1*U),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: StatusParse.MiniStatus ->
                 case ds of wild { StatusParse.MkMiniStatus index ds1 ->
                 case index of wild1 { GHC.Types.C# c1 ->
                 case c1 of wild2 {
                   DEFAULT -> GHC.Types.False '?' -> GHC.Types.True } } }) -}
f280346d38f79f1e76d1f3c4fa6195ba
  processStatus ::
    [GHC.Base.String]
    -> GHC.Base.Maybe (StatusParse.Status GHC.Types.Int)
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ statLines :: [GHC.Base.String] ->
                 case StatusParse.processStatus_go statLines of wild {
                   GHC.Base.Nothing
                   -> GHC.Base.Nothing @ (StatusParse.Status GHC.Types.Int)
                   GHC.Base.Just x
                   -> GHC.Base.Just
                        @ (StatusParse.Status GHC.Types.Int)
                        (StatusParse.countStatus x) }) -}
5c45988ebb6ca0fd2f68c0f8cca3200c
  processStatus_go ::
    [GHC.Base.String] -> GHC.Base.Maybe [StatusParse.MiniStatus]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
2bdf9a3158b1d09b7d9ed967b8638e68
  staged :: StatusParse.Status a -> a
  RecSel StatusParse.Status
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLLL),1*U(1*U,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ds :: StatusParse.Status a ->
                 case ds of wild { StatusParse.MakeStatus ds1 ds2 ds3 ds4 ->
                 ds1 }) -}
f79602cb5385edc0bf3b0647fcdad57e
  untracked :: StatusParse.Status a -> a
  RecSel StatusParse.Status
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLLS),1*U(A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ds :: StatusParse.Status a ->
                 case ds of wild { StatusParse.MakeStatus ds1 ds2 ds3 ds4 ->
                 ds4 }) -}
instance GHC.Classes.Eq [StatusParse.Status]
  = StatusParse.$fEqStatus
instance GHC.Show.Show [StatusParse.Status]
  = StatusParse.$fShowStatus
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False


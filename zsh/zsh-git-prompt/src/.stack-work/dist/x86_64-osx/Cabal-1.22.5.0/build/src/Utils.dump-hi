
==================== FINAL INTERFACE ====================
2019-02-04 11:14:20.691368 UTC

interface gitpr_GyKbGQsRujX2Ik9bjYPmgX:Utils 7103
  interface hash: 1b52be9f2404e669a714a2fc74ae5188
  ABI hash: 0cc6b9aea5c72eb4c4b92c3b434e2d09
  export-list hash: b24fcd362b619ad0430d0430908527dd
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 4c0a7b65a6dddbc4161c2e2bfabe3dc3
  sig of: Nothing
  used TH splices: False
  where
exports:
  Utils.branchOrHashWith
  Utils.processBranch
  Utils.processGitStatus
  Utils.rightOrNothing
  Utils.showBranchInfo
  Utils.showGitInfo
  Utils.showRemoteNumbers
  Utils.showStatusNumbers
  Utils.stringsFromStatus
  Utils.GitInfo{Utils.MkGitInfo}
  Utils.Hash{Utils.MkHash Utils.getHash}
module dependencies: BranchParse StatusParse
package dependencies: QuickCheck-2.8.1@Quick_8UnGnTXfSEEClQczG6tI7s
                      array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA base-4.8.2.0*
                      binary-0.7.5.0@binar_3uXFWMoAGBg0xKP9MHKRwi
                      bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6
                      containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0 mtl-2.2.1@mtl_Aue4leSeVkpKLsfHIV51E8
                      parsec-3.1.9@parse_EE5NO1mlYLh4J8mgDEshNv
                      pretty-1.1.2.0@prett_JItwetRppk1H5Uq3xbjDGC
                      primitive-0.6.1.0@primi_EphY2c7CCxSCBKjAN0YTR3
                      random-1.1@rando_9Kgekc9yEaLHLNUuw6paWL template-haskell-2.10.0.0
                      text-1.2.2.0@text_5c7VCmRXJenGcMPs3kwpkI
                      tf-random-0.5@tfran_1eLmkn3WUnC8NZpPuDLGKF
                      time-1.5.0.1@time_FTheb6LSxyX1UABIbBXRfn
                      transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
         binary-0.7.5.0@binar_3uXFWMoAGBg0xKP9MHKRwi:Data.Binary.Generic
         bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6:Data.ByteString.Builder
         text-1.2.2.0@text_5c7VCmRXJenGcMPs3kwpkI:Data.Text
         text-1.2.2.0@text_5c7VCmRXJenGcMPs3kwpkI:Data.Text.Lazy
         text-1.2.2.0@text_5c7VCmRXJenGcMPs3kwpkI:Data.Text.Show
         time-1.5.0.1@time_FTheb6LSxyX1UABIbBXRfn:Data.Time.Calendar.Gregorian
         time-1.5.0.1@time_FTheb6LSxyX1UABIbBXRfn:Data.Time.Format.Parse
         time-1.5.0.1@time_FTheb6LSxyX1UABIbBXRfn:Data.Time.LocalTime.LocalTime
         transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF:Control.Monad.Trans.Error
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.IntMap.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.IntSet.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Sequence
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
                         pretty-1.1.2.0@prett_JItwetRppk1H5Uq3xbjDGC:Text.PrettyPrint.HughesPJ
                         primitive-0.6.1.0@primi_EphY2c7CCxSCBKjAN0YTR3:Control.Monad.Primitive
                         template-haskell-2.10.0.0:Language.Haskell.TH.Syntax
                         text-1.2.2.0@text_5c7VCmRXJenGcMPs3kwpkI:Data.Text
                         text-1.2.2.0@text_5c7VCmRXJenGcMPs3kwpkI:Data.Text.Lazy
import  -/  base-4.8.2.0:Data.Either e8724afd65fd432cfe9a54014f5f762d
import  -/  base-4.8.2.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.2.0:Data.OldList d8fd80b0e14aa085ce6219cd89dad356
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  BranchParse 1e5e195ae70e90b84f91dba4c1309f6d
  exports: 31ed7a88d826371e4a9ed18cde838aba
  BranchInfo cef72515ed3d434c3acceafa44cad2b9
  MBranchInfo f36409d3ccbfa292533e205b4b1699da
  MkBranch 3d4bb596bfb6d02741c17bc97731248d
  MkBranchInfo b51439e16693377c99ea52f24d962d04
  Remote 5d2ed2340c29307e445aeb4812400c2f
  branchInfo 4aaa5013f13ee1be7900d76ae78ab7d2
  getDistance 4948d12ae754a5a93c1ae19a6ed42dd1
  pairFromDistance ba40fccafa85bd60d610c68af4cd89a8
import  -/  StatusParse b9489809b2cc70ff55397d3768566180
  exports: d57064a6aca95ce6bc537df92c062998
  MakeStatus d18a9010e9e6c1182fd5e272716093fc
  Status 7a89a29ab39a6bc916937d665ad05825
  processStatus f280346d38f79f1e76d1f3c4fa6195ba
30296358ac793e62ad73a9ebb2cf1539
  $wshowGitInfo ::
    GHC.Base.Maybe Utils.Hash
    -> BranchParse.MBranchInfo
    -> StatusParse.Status GHC.Types.Int
    -> [GHC.Base.String]
  {- Arity: 3,
     Strictness: <L,1*U><S,1*U><L,1*U(1*U(U),1*U(U),1*U(U),1*U(U))>,
     Inline: [0] -}
ca51f14f4c9a5ce88670e872f5519b97
  $wshowRemoteNumbers ::
    GHC.Base.Maybe BranchParse.Remote
    -> (# GHC.Base.String, [GHC.Base.String] #)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U>, Inline: [0],
     Unfolding: (\ w :: GHC.Base.Maybe BranchParse.Remote ->
                 let {
                   ds :: (GHC.Types.Int, GHC.Types.Int)
                   = case w of wild {
                       GHC.Base.Nothing -> Utils.showRemoteNumbers1
                       GHC.Base.Just x
                       -> case x of wild1 { BranchParse.MkRemote ds1 md ->
                          case md of wild2 {
                            GHC.Base.Nothing -> Utils.showRemoteNumbers1
                            GHC.Base.Just x1
                            -> case x1 of wild3 {
                                 BranchParse.Ahead n -> (n, BranchParse.pairFromDistance1)
                                 BranchParse.Behind n -> (BranchParse.pairFromDistance1, n)
                                 BranchParse.AheadBehind m n -> (m, n) } } } }
                 } in
                 (# case ds of wild { (,) ahead behind ->
                    case ahead of ww2 { GHC.Types.I# ww3 ->
                    case GHC.Show.$wshowSignedInt
                           0
                           ww3
                           (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                    GHC.Types.: @ GHC.Types.Char ww5 ww6 } } },
                    GHC.Types.:
                      @ GHC.Base.String
                      (case ds of wild { (,) ahead behind ->
                       case behind of ww2 { GHC.Types.I# ww3 ->
                       case GHC.Show.$wshowSignedInt
                              0
                              ww3
                              (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                       GHC.Types.: @ GHC.Types.Char ww5 ww6 } } })
                      (GHC.Types.[] @ GHC.Base.String) #)) -}
69e2aa61afe8462e6bf919e109e412b5
  data GitInfo
    = MkGitInfo BranchParse.MBranchInfo
                (StatusParse.Status GHC.Types.Int)
d3eec4226c16864bf22f331a90a09fc6
  newtype Hash = MkHash {getHash :: GHC.Base.String}
725fb7ebf9b3c4563f2b6c788030ec97
  branchOrHashWith ::
    GHC.Types.Char
    -> GHC.Base.Maybe Utils.Hash
    -> GHC.Base.Maybe BranchParse.BranchInfo
    -> BranchParse.BranchInfo
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Char
                   ds1 :: GHC.Base.Maybe Utils.Hash
                   ds2 :: GHC.Base.Maybe BranchParse.BranchInfo ->
                 case ds2 of wild {
                   GHC.Base.Nothing
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing -> Utils.branchOrHashWith1
                        GHC.Base.Just hash
                        -> BranchParse.MkBranchInfo
                             (GHC.Types.: @ GHC.Types.Char ds hash `cast` (Utils.NTCo:Hash[0]))
                               `cast`
                             (Sym (BranchParse.NTCo:Branch[0]))
                             (GHC.Base.Nothing @ BranchParse.Remote) }
                   GHC.Base.Just bi -> bi }) -}
ca7988646a95215f9e78706e90c6857c
  branchOrHashWith1 :: BranchParse.BranchInfo
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (BranchParse.MkBranchInfo
                   (GHC.Types.[] @ GHC.Types.Char)
                     `cast`
                   (Sym (BranchParse.NTCo:Branch[0]))
                   (GHC.Base.Nothing @ BranchParse.Remote)) -}
2b8ea0bff58dc7eca2b2211a6357f09c
  getHash :: Utils.Hash -> GHC.Base.String
  RecSel Utils.Hash
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Utils.getHash1 `cast` (<Utils.Hash>_R ->_R Utils.NTCo:Hash[0]) -}
afe379d4f850e04da2d99e67aeaefaf7
  getHash1 :: Utils.Hash -> Utils.Hash
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True) (\ ds :: Utils.Hash -> ds) -}
7c89bf0d05ff67bc1dc1577dea636d40
  processBranch ::
    GHC.Base.String -> GHC.Base.Maybe BranchParse.MBranchInfo
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ x :: GHC.Base.String ->
                 case (Text.Parsec.Prim.runPT
                         @ GHC.Base.String
                         @ ()
                         @ Data.Functor.Identity.Identity
                         @ BranchParse.MBranchInfo
                         @ GHC.Types.Char
                         (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                         BranchParse.branchInfo2
                           `cast`
                         (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                                   <[GHC.Types.Char]>_R
                                   <()>_R
                                   <Data.Functor.Identity.Identity>_R
                                   <BranchParse.MBranchInfo>_R))
                         GHC.Tuple.()
                         (GHC.Types.[] @ GHC.Types.Char)
                         x)
                        `cast`
                      (Data.Functor.Identity.NTCo:Identity[0]
                           <Data.Either.Either
                              Text.Parsec.Error.ParseError BranchParse.MBranchInfo>_R) of wild {
                   Data.Either.Left x1 -> GHC.Base.Nothing @ BranchParse.MBranchInfo
                   Data.Either.Right y
                   -> GHC.Base.Just @ BranchParse.MBranchInfo y }) -}
c0011d04dea3922fd846a1ad52baef66
  processGitStatus ::
    [GHC.Base.String] -> GHC.Base.Maybe Utils.GitInfo
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ ds :: [GHC.Base.String] ->
                 case ds of wild {
                   [] -> GHC.Base.Nothing @ Utils.GitInfo
                   : branchLine statusLines
                   -> case (Text.Parsec.Prim.runPT
                              @ GHC.Base.String
                              @ ()
                              @ Data.Functor.Identity.Identity
                              @ BranchParse.MBranchInfo
                              @ GHC.Types.Char
                              (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                              BranchParse.branchInfo2
                                `cast`
                              (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                                        <[GHC.Types.Char]>_R
                                        <()>_R
                                        <Data.Functor.Identity.Identity>_R
                                        <BranchParse.MBranchInfo>_R))
                              GHC.Tuple.()
                              (GHC.Types.[] @ GHC.Types.Char)
                              branchLine)
                             `cast`
                           (Data.Functor.Identity.NTCo:Identity[0]
                                <Data.Either.Either
                                   Text.Parsec.Error.ParseError
                                   BranchParse.MBranchInfo>_R) of wild1 {
                        Data.Either.Left x -> GHC.Base.Nothing @ Utils.GitInfo
                        Data.Either.Right y
                        -> case StatusParse.processStatus_go statusLines of wild2 {
                             GHC.Base.Nothing -> GHC.Base.Nothing @ Utils.GitInfo
                             GHC.Base.Just x
                             -> GHC.Base.Just
                                  @ Utils.GitInfo
                                  (Utils.MkGitInfo y (StatusParse.countStatus x)) } } }) -}
99bb11e68ef395c90b4d1e07f5a11f59
  rightOrNothing :: Data.Either.Either a b -> GHC.Base.Maybe b
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ b ds1 :: Data.Either.Either a b ->
                 case ds1 of wild {
                   Data.Either.Left x -> GHC.Base.Nothing @ b
                   Data.Either.Right y -> GHC.Base.Just @ b y }) -}
f187bb9ce9857c08c2841eddf9e1df17
  showBranchInfo :: BranchParse.BranchInfo -> [GHC.Base.String]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,1*U)>m2,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: BranchParse.BranchInfo ->
                 case ds of wild { BranchParse.MkBranchInfo branch mremote ->
                 GHC.Types.:
                   @ GHC.Base.String
                   branch `cast` (BranchParse.NTCo:Branch[0])
                   (Utils.showRemoteNumbers mremote) }) -}
95576c66aaf80ef9a4fd8d91113f3de1
  showGitInfo ::
    GHC.Base.Maybe Utils.Hash -> Utils.GitInfo -> [GHC.Base.String]
  {- Arity: 2,
     Strictness: <L,1*U><S(SL),1*U(1*U,1*U(1*U(U),1*U(U),1*U(U),1*U(U)))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Base.Maybe Utils.Hash w1 :: Utils.GitInfo ->
                 case w1 of ww { Utils.MkGitInfo ww1 ww2 ->
                 Utils.$wshowGitInfo w ww1 ww2 }) -}
3d036645210eef07a0666cbd2ee5f9c3
  showRemoteNumbers ::
    GHC.Base.Maybe BranchParse.Remote -> [GHC.Base.String]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U>m2,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Base.Maybe BranchParse.Remote ->
                 case Utils.$wshowRemoteNumbers w of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ GHC.Base.String ww1 ww2 }) -}
7411353d3bf637d3398851f18851827b
  showRemoteNumbers1 :: (GHC.Types.Int, GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((Utils.showRemoteNumbers2,
                  Utils.showRemoteNumbers2)) -}
8370f21fae55be630eda2bdd626ea0e0
  showRemoteNumbers2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
86002114bda90bda541b959f6323b46f
  showStatusNumbers ::
    StatusParse.Status GHC.Types.Int -> [GHC.Base.String]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S,1*U(1*U(U),1*U(U),1*U(U),1*U(U))>m2,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: StatusParse.Status GHC.Types.Int ->
                 case w of ww { StatusParse.MakeStatus ww1 ww2 ww3 ww4 ->
                 GHC.Types.:
                   @ GHC.Base.String
                   (GHC.Show.$fShowInt_$cshow ww1)
                   (GHC.Types.:
                      @ GHC.Base.String
                      (GHC.Show.$fShowInt_$cshow ww2)
                      (GHC.Types.:
                         @ GHC.Base.String
                         (GHC.Show.$fShowInt_$cshow ww3)
                         (GHC.Types.:
                            @ GHC.Base.String
                            (GHC.Show.$fShowInt_$cshow ww4)
                            (GHC.Types.[] @ GHC.Base.String)))) }) -}
d72b26a5d0f0251f1a427f2e9d07d064
  stringsFromStatus ::
    GHC.Base.Maybe Utils.Hash
    -> GHC.Base.String -> GHC.Base.Maybe [GHC.Base.String]
  {- Arity: 2, Strictness: <L,1*U><S,1*U>,
     Unfolding: (\ h :: GHC.Base.Maybe Utils.Hash
                   status :: GHC.Base.String ->
                 case Utils.processGitStatus (Data.OldList.lines status) of wild {
                   GHC.Base.Nothing -> GHC.Base.Nothing @ [GHC.Base.String]
                   GHC.Base.Just x
                   -> GHC.Base.Just @ [GHC.Base.String] (Utils.showGitInfo h x) }) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

